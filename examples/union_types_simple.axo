// UNION TYPES TEST - Testing union type declarations (type aliases only)
print("=== AXOLOTL UNION TYPES TEST ===");

// Test 1: Basic Union Type Aliases
print("\n1. Basic Union Type Aliases");
type StringOrInt = string|int;
type BoolOrFloat = bool|float;
type NumberType = int|float;

// Note: Variables can be declared with union types, values are checked at runtime
var value1: StringOrInt = "hello";
var value2: StringOrInt = 42;
var value3: BoolOrFloat = true;
var value4: BoolOrFloat = 3.14;

print("âœ“ Union type variables:", value1, value2, value3, value4);

// Test 2: Multi-Type Unions
print("\n2. Multi-Type Unions");
type MultiType = int|float|string|bool;

var multi1: MultiType = 100;
var multi2: MultiType = 2.71;
var multi3: MultiType = "text";
var multi4: MultiType = false;

print("âœ“ Multi-type unions:", multi1, multi2, multi3, multi4);

// Test 3: Union Types with Arrays
print("\n3. Union Types with Arrays");
type MixedArray = [string|int];

// Arrays can hold mixed types when declared with union element types
var mixed: MixedArray = ["hello", 42, "world", 123];
print("âœ“ Mixed array:", mixed);

// Test 4: Union Types in Object Fields
print("\n4. Union Types in Object Fields");
type FlexibleRecord = {
    id: string|int,
    value: int|float,
    active: bool|string
};

var record1: FlexibleRecord = {
    id: "user_123",
    value: 42,
    active: true
};

var record2: FlexibleRecord = {
    id: 456,
    value: 3.14,
    active: "yes"
};

print("âœ“ Flexible records:", record1, record2);

// Test 5: Nested Union Types
print("\n5. Nested Union Types");
type NestedUnion = {
    data: [string|int],
    config: {
        mode: string|int,
        enabled: bool|string
    }
};

var nested: NestedUnion = {
    data: ["item", 42, "test", 99],
    config: {
        mode: "production",
        enabled: true
    }
};

print("âœ“ Nested union types:", nested);

// Test 6: Functions with Union Type Parameters (using any for now)
print("\n6. Functions with Union-like Parameters");

func processAny(input: any) -> string {
    var type: string = typeof(input);
    return "Type: " + type + ", Value: " + toString(input);
}

// Simulate union type behavior with any
var unionValue1: StringOrInt = "test";
var unionValue2: StringOrInt = 789;

print("âœ“ Process union value 1:", processAny(unionValue1));
print("âœ“ Process union value 2:", processAny(unionValue2));

// Test 7: Type Checking with Union Types
print("\n7. Type Checking with Union Types");

func handleStringOrInt(value: any) -> string {
    var type: string = typeof(value);
    
    if (type == "string") {
        return "String processing: " + toUpper(value);
    } else if (type == "int") {
        return "Integer processing: " + toString(value * 2);
    } else {
        return "Unknown type: " + type;
    }
}

var testValue1: StringOrInt = "hello";
var testValue2: StringOrInt = 25;

print("âœ“ Handle string:", handleStringOrInt(testValue1));
print("âœ“ Handle int:", handleStringOrInt(testValue2));

// Test 8: Union Types with Custom Types
print("\n8. Union Types with Custom Types");
type User = {name: string, age: int};
type Product = {title: string, price: float};
type Entity = User|Product;  // Union of custom types

// Note: Runtime type checking needed to distinguish
var entity1: Entity = {name: "Alice", age: 30};
var entity2: Entity = {title: "Laptop", price: 999.99};

print("âœ“ Entity 1 (User):", entity1);
print("âœ“ Entity 2 (Product):", entity2);

// Test 9: Array of Union Types
print("\n9. Array of Union Types");
type ValueArray = [int|string|bool];

var values: ValueArray = [42, "hello", true, 123, "world", false];
print("âœ“ Mixed value array:", values);

// Process array with type checking
func processValueArray(arr: ValueArray) -> [string] {
    var results: [string] = [];
    
    for (var i: int = 0; i < len(arr); i = i + 1) {
        var item: any = arr[i];
        var type: string = typeof(item);
        var processed: string = type + ":" + toString(item);
        push(results, processed);
    }
    
    return results;
}

var processed: [string] = processValueArray(values);
print("âœ“ Processed array:", processed);

// Test 10: Complex Union Combinations
print("\n10. Complex Union Combinations");
type ComplexUnion = {
    id: string|int,
    data: [string|int|bool],
    metadata: {
        type: string|int,
        flags: [bool|string]
    }
};

var complex: ComplexUnion = {
    id: "complex_001",
    data: [1, "two", true, 4, "five"],
    metadata: {
        type: 42,
        flags: [true, "enabled", false, "debug"]
    }
};

print("âœ“ Complex union structure:", complex);

// Test 11: Union Types for Configuration
print("\n11. Union Types for Configuration");
type ConfigValue = string|int|bool|float;
type Configuration = {
    host: string|int,  // Could be hostname or IP as int
    port: int,
    debug: bool|string,  // true/false or "verbose"
    timeout: int|float,  // seconds as int or float
    features: [string|bool]  // feature names or enabled flags
};

var config: Configuration = {
    host: "localhost",
    port: 8080,
    debug: "verbose",
    timeout: 30.5,
    features: ["auth", true, "api", false, "logging"]
};

print("âœ“ Configuration with unions:", config);

// Test 12: Error Handling with Union Types
print("\n12. Error Handling with Union Types");
type Result = string|int;  // Success message or error code

func simulateOperation(success: bool) -> Result {
    if (success) {
        return "Operation completed successfully";
    } else {
        return -1;  // Error code
    }
}

func handleResult(result: Result) -> string {
    var type: string = typeof(result);
    
    if (type == "string") {
        return "Success: " + result;
    } else {
        return "Error code: " + toString(result);
    }
}

var success: Result = simulateOperation(true);
var failure: Result = simulateOperation(false);

print("âœ“ Success result:", handleResult(success));
print("âœ“ Failure result:", handleResult(failure));

// Test 13: Performance with Union Types
print("\n13. Performance with Union Types");
type PerformanceData = int|string|bool;

func processLargeUnionArray(size: int) -> [PerformanceData] {
    var data: [PerformanceData] = [];
    
    for (var i: int = 0; i < size; i = i + 1) {
        var mod: int = i % 3;
        if (mod == 0) {
            push(data, i);
        } else if (mod == 1) {
            push(data, "item_" + toString(i));
        } else {
            push(data, i % 2 == 0);
        }
    }
    
    return data;
}

var perfStart: int = millis();
var largeData: [PerformanceData] = processLargeUnionArray(100);
var perfEnd: int = millis();

print("âœ“ Large union array created");
print("âœ“ Array size:", len(largeData));
print("âœ“ Time taken:", perfEnd - perfStart, "ms");
print("âœ“ Sample items:", largeData[0], largeData[1], largeData[2]);

// Test 14: Union Types with Type Validation
print("\n14. Union Types with Type Validation");

func validateStringOrInt(value: any) -> bool {
    var type: string = typeof(value);
    return type == "string" || type == "int";
}

func validateNumberType(value: any) -> bool {
    var type: string = typeof(value);
    return type == "int" || type == "float";
}

// Test validation
var testValues: [any] = ["hello", 42, 3.14, true, "world"];

print("âœ“ Validation results:");
for (var i: int = 0; i < len(testValues); i = i + 1) {
    var val: any = testValues[i];
    var isStringOrInt: bool = validateStringOrInt(val);
    var isNumber: bool = validateNumberType(val);
    print("  Value:", val, "StringOrInt:", isStringOrInt, "Number:", isNumber);
}

// Final Summary
print("\n=== UNION TYPES SUMMARY ===");
print("âœ… All 14 union type test categories completed!");
print("ðŸŽ¯ Union type features tested:");
print("   â€¢ Basic union type aliases (A|B)");
print("   â€¢ Multi-type unions (A|B|C|D)");
print("   â€¢ Union types with arrays");
print("   â€¢ Union types in object fields");
print("   â€¢ Nested union structures");
print("   â€¢ Runtime type checking with unions");
print("   â€¢ Union types with custom types");
print("   â€¢ Arrays of union types");
print("   â€¢ Complex union combinations");
print("   â€¢ Configuration with union types");
print("   â€¢ Error handling patterns");
print("   â€¢ Performance with union types");
print("   â€¢ Type validation functions");
print("\nðŸš€ Axolotl's union type system provides flexible type definitions!");