// CUSTOM TYPES TEST - Testing type declarations and custom type system
print("=== AXOLOTL CUSTOM TYPES TEST ===");

// Test 1: Basic Type Declarations
print("\n1. Basic Type Declarations");
type UserId = int;
type UserName = string;
type IsActive = bool;

var id: UserId = 12345;
var name: UserName = "Alice";
var active: IsActive = true;

print("âœ“ Custom basic types:", id, name, active);

// Test 2: Object Type Definitions
print("\n2. Object Type Definitions");
type User = {name: string, age: int, email: string};
type Config = {debug: bool, version: string, port: int};

var user1: User = {name: "Bob", age: 30, email: "bob@test.com"};
var config1: Config = {debug: true, version: "1.0", port: 8080};

print("âœ“ Custom object types:", user1, config1);

// Test 3: Array Type Definitions
print("\n3. Array Type Definitions");
type IntList = [int];
type StringList = [string];
type UserList = [User];

var numbers: IntList = [1, 2, 3, 4, 5];
var words: StringList = ["hello", "world", "test"];
var users: UserList = [
    {name: "Charlie", age: 25, email: "charlie@test.com"},
    {name: "Diana", age: 28, email: "diana@test.com"}
];

print("âœ“ Custom array types:", numbers, words, users);

// Test 4: Nested Custom Types
print("\n4. Nested Custom Types");
type Address = {street: string, city: string, zip: int};
type Employee = {
    id: UserId,
    name: UserName,
    address: Address,
    active: IsActive
};

var emp1: Employee = {
    id: 1001,
    name: "Eve",
    address: {street: "123 Main St", city: "Boston", zip: 12345},
    active: true
};

print("âœ“ Nested custom types:", emp1);

// Test 5: Function Types with Custom Types
print("\n5. Function Types with Custom Types");
func createUser(id: UserId, name: UserName, age: int) -> User {
    return {
        name: name,
        age: age,
        email: name + "@company.com"
    };
}

func processUsers(userList: UserList) -> IntList {
    var ages: IntList = [];
    for (var i: int = 0; i < len(userList); i = i + 1) {
        push(ages, userList[i].age);
    }
    return ages;
}

var newUser: User = createUser(2001, "Frank", 35);
var allAges: IntList = processUsers(users);

print("âœ“ Created user:", newUser);
print("âœ“ Extracted ages:", allAges);

// Test 6: Union-like Types (simulated)
print("\n6. Union-like Types (simulated)");
type Status = string; // Could be "active", "inactive", "pending"
type Priority = int;  // Could be 1, 2, 3

type Task = {
    id: int,
    title: string,
    status: Status,
    priority: Priority
};

var task1: Task = {
    id: 101,
    title: "Fix bug",
    status: "active",
    priority: 1
};

var task2: Task = {
    id: 102,
    title: "Add feature",
    status: "pending",
    priority: 2
};

print("âœ“ Task types:", task1, task2);

// Test 7: Complex Nested Structures
print("\n7. Complex Nested Structures");
type Department = {
    name: string,
    employees: UserList,
    budget: int
};

type Company = {
    name: string,
    departments: [Department],
    founded: int
};

var engineering: Department = {
    name: "Engineering",
    employees: [
        {name: "Alice", age: 30, email: "alice@tech.com"},
        {name: "Bob", age: 28, email: "bob@tech.com"}
    ],
    budget: 500000
};

var marketing: Department = {
    name: "Marketing", 
    employees: [
        {name: "Carol", age: 32, email: "carol@tech.com"}
    ],
    budget: 200000
};

var company: Company = {
    name: "TechCorp",
    departments: [engineering, marketing],
    founded: 2020
};

print("âœ“ Complex company structure:", company);

// Test 8: Type-Safe Operations
print("\n8. Type-Safe Operations");
func calculateTotalBudget(comp: Company) -> int {
    var total: int = 0;
    for (var i: int = 0; i < len(comp.departments); i = i + 1) {
        total = total + comp.departments[i].budget;
    }
    return total;
}

func countEmployees(comp: Company) -> int {
    var count: int = 0;
    for (var i: int = 0; i < len(comp.departments); i = i + 1) {
        count = count + len(comp.departments[i].employees);
    }
    return count;
}

var totalBudget: int = calculateTotalBudget(company);
var totalEmployees: int = countEmployees(company);

print("âœ“ Total budget:", totalBudget);
print("âœ“ Total employees:", totalEmployees);

// Test 9: Generic-like Behavior with Custom Types
print("\n9. Generic-like Behavior with Custom Types");
type Container = {
    data: [int],
    size: int,
    capacity: int
};

func createContainer(cap: int) -> Container {
    return {
        data: [],
        size: 0,
        capacity: cap
    };
}

func addToContainer(container: Container, value: int) -> Container {
    if (container.size < container.capacity) {
        container.size = container.size + 1;
    }
    return container;
}

var myContainer: Container = createContainer(5);
var containerData: [int] = [];
push(containerData, 10);
push(containerData, 20);
push(containerData, 30);
myContainer.data = containerData;
myContainer.size = 3;

print("âœ“ Container:", myContainer);

// Test 10: Type Validation in Functions
print("\n10. Type Validation in Functions");
func validateUser(user: User) -> bool {
    if (len(user.name) == 0) {
        return false;
    }
    if (user.age < 0 || user.age > 150) {
        return false;
    }
    if (len(user.email) == 0) {
        return false;
    }
    return true;
}

func filterValidUsers(userList: UserList) -> UserList {
    var valid: UserList = [];
    for (var i: int = 0; i < len(userList); i = i + 1) {
        if (validateUser(userList[i])) {
            push(valid, userList[i]);
        }
    }
    return valid;
}

var testUsers: UserList = [
    {name: "Valid User", age: 25, email: "valid@test.com"},
    {name: "", age: 30, email: "invalid@test.com"}, // Invalid: empty name
    {name: "Another Valid", age: 35, email: "another@test.com"}
];

var validUsers: UserList = filterValidUsers(testUsers);
print("âœ“ Valid users:", validUsers);

// Test 11: Recursive Type Structures
print("\n11. Recursive Type Structures");
type TreeNode = {
    value: int,
    children: [TreeNode]
};

func createLeaf(val: int) -> TreeNode {
    return {value: val, children: []};
}

func createNode(val: int, childNodes: [TreeNode]) -> TreeNode {
    return {value: val, children: childNodes};
}

var leaf1: TreeNode = createLeaf(1);
var leaf2: TreeNode = createLeaf(2);
var leaf3: TreeNode = createLeaf(3);

var branch: TreeNode = createNode(10, [leaf1, leaf2]);
var root: TreeNode = createNode(100, [branch, leaf3]);

print("âœ“ Tree structure:", root);

// Test 12: Type Aliases for Complex Types
print("\n12. Type Aliases for Complex Types");
type Matrix = [[int]];
type StringMatrix = [[string]];
type Coordinates = {x: int, y: int};
type Path = [Coordinates];

var matrix2D: Matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
var stringGrid: StringMatrix = [["a", "b"], ["c", "d"]];

var point1: Coordinates = {x: 10, y: 20};
var point2: Coordinates = {x: 30, y: 40};
var route: Path = [point1, point2, {x: 50, y: 60}];

print("âœ“ Matrix:", matrix2D);
print("âœ“ String grid:", stringGrid);
print("âœ“ Path:", route);

// Test 13: Function Types as Custom Types
print("\n13. Function Types as Custom Types");
type Processor = func;
type Validator = func;

var numberProcessor: Processor = func(x: int) -> int {
    return x * x;
};

var stringValidator: Validator = func(s: string) -> bool {
    return len(s) > 0;
};

print("âœ“ Number processor result:", numberProcessor(5));
print("âœ“ String validator result:", stringValidator("test"));

// Test 14: Configuration Types
print("\n14. Configuration Types");
type DatabaseConfig = {
    host: string,
    port: int,
    database: string,
    ssl: bool
};

type ServerConfig = {
    port: int,
    host: string,
    debug: bool,
    database: DatabaseConfig
};

var dbConfig: DatabaseConfig = {
    host: "localhost",
    port: 5432,
    database: "myapp",
    ssl: false
};

var serverConfig: ServerConfig = {
    port: 8080,
    host: "0.0.0.0",
    debug: true,
    database: dbConfig
};

print("âœ“ Server configuration:", serverConfig);

// Test 15: Type-Safe Data Processing Pipeline
print("\n15. Type-Safe Data Processing Pipeline");
type RawData = {id: int, value: string};
type ProcessedData = {id: int, numValue: int, valid: bool};
type DataPipeline = [ProcessedData];

func processRawData(raw: [RawData]) -> DataPipeline {
    var processed: DataPipeline = [];
    
    for (var i: int = 0; i < len(raw); i = i + 1) {
        var item: RawData = raw[i];
        var numVal: int = 0;
        var isValid: bool = true;
        
        // Simple number parsing simulation
        if (item.value == "zero") {
            numVal = 0;
        } else if (item.value == "one") {
            numVal = 1;
        } else if (item.value == "two") {
            numVal = 2;
        } else {
            isValid = false;
        }
        
        var processedItem: ProcessedData = {
            id: item.id,
            numValue: numVal,
            valid: isValid
        };
        
        push(processed, processedItem);
    }
    
    return processed;
}

var rawInput: [RawData] = [
    {id: 1, value: "one"},
    {id: 2, value: "two"},
    {id: 3, value: "invalid"},
    {id: 4, value: "zero"}
];

var pipeline: DataPipeline = processRawData(rawInput);
print("âœ“ Data pipeline result:", pipeline);

// Final Summary
print("\n=== CUSTOM TYPES SUMMARY ===");
print("âœ… All 15 custom type test categories completed!");
print("ðŸŽ¯ Custom type features tested:");
print("   â€¢ Basic type aliases (type Name = BaseType)");
print("   â€¢ Object type definitions (type Obj = {field: type})");
print("   â€¢ Array type definitions (type Arr = [type])");
print("   â€¢ Nested custom types");
print("   â€¢ Function parameters with custom types");
print("   â€¢ Function return types with custom types");
print("   â€¢ Complex nested structures");
print("   â€¢ Type-safe operations");
print("   â€¢ Generic-like behavior");
print("   â€¢ Type validation");
print("   â€¢ Recursive type structures");
print("   â€¢ Type aliases for complex types");
print("   â€¢ Function types as custom types");
print("   â€¢ Configuration types");
print("   â€¢ Data processing pipelines");
print("\nðŸš€ Axolotl's custom type system is powerful and working correctly!");